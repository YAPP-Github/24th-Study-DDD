# 7. 애그리거트 트랜잭션 관리


## 8.1 애그리거트와 트랜잭션

트랜잭션 처리 방법에는 선점(Pessimistic) 잠금과 비선점(Optimistic) 잠금이 있다.

## 8.2 선점 잠금

Pessimistic 잠금은

애그리거트를 구한 스레드가 애그리거르 사용이 끝날 때 까지,
다른 스레드가 해당 애그리거트를 수정하지 못하게 막는 방식이다.

→ 동시에 수정할 수 없기에 데이터 충돌 문제를 해결할 수 있다.

### 사용 방법

@Lock 어노테이션을 붙여서 잠금 모드를 사용

### 단점

비관적 락은 교착 상태에 빠져, 성능저하나 데드락(교착상태)이 발생할 수 있다.

데드락은 상대적으로 사용자 수가 많을 때, 발생할 가능성이 높고, 사용자 수가 많으면 데드락에 빠지는 스레드는 더 빠르게 증가한다.

→ 최대 대기 시간을 지정해야된다.

JPA에서는 힌트(hint)를 사용해서 처리한다.

## 8.3 비선점 잠금

버전 관리를 통해 트랜잭션을 관리한다.

JPA 에서는 @Version 어노테이션을 사용하여 버젼에 추가할 컬럼을 설정할 수 있다.

### 강제 버전 증가

루트 엔티티 값이 바뀌지 않았더라고 애그리거트의 구성요소 중

일부 값이 바뀌면 논리적으로 그 애그리거트는 바뀐것이다.

→ 애그리거트 내의 어떤 구성요소의 상태가 바뀌면 루트 애그리거트의 버젼 값이 증가해야 비선점 잠금이 올바르게 작동한다.

→ JPA 에서는 `LockModeTypa.OPTIMISITIC_FORCE_INCREMENT` 를 사용하여 해결한다

## 8.4 오프라인 선점 잠금

더 엄격하게 데이터 충돌을 막고 싶다면 오프라인 선점 잠금은 여러 트랜잭션에 걸쳐 동시 변경을 막는다.

첫 번째 트랜잭션을 시작할 때 오프라인 잠금을 선점하고 마지막 트랜잭션에서 잠금을 해제한다.

잠금을 해제하기 전 까지 다른 사용자는 잠금을 구할 수 없다.

→ 수정 기능의 경우 조회할때 트랜잭션에서 오프라인 잠금을, 수정할때 트랜잭션에서 오프라인 잠금을 해제한다.

오프라인 선점 잠금을 하기 위해선,  크게 잠금 선점 시도, 잠금 확인, 잠금 해제, 락 유효 시간 연장의 네가지 기능을 제공해야 한다.